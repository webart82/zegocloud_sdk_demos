import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:zego_express_engine/zego_express_engine.dart';
import 'utils/zegocloud_token.dart';

import 'key_center.dart';

class LivePage extends StatefulWidget {
  const LivePage({
    Key? key,
    required this.isHost,
    required this.localUserID,
    required this.localUserName,
    required this.roomID,
  }) : super(key: key);

  final bool isHost;
  final String localUserID;
  final String localUserName;
  final String roomID;

  @override
  State<LivePage> createState() => _LivePageState();
}

class _LivePageState extends State<LivePage> {
  Widget? hostCameraView;
  int? hostCameraViewID;

  Widget? hostScreenView;
  int? hostScreenViewID;

  bool isCameraEnabled = true;
  bool isSharingScreen = false;
  ZegoScreenCaptureSource? screenSharingController;

  @override
  void initState() {
    startListenEvent();
    loginRoom();
    super.initState();
  }

  @override
  void dispose() {
    stopListenEvent();
    logoutRoom();
    super.dispose();
  }

  Widget get screenView => isSharingScreen ? (hostScreenView ?? const SizedBox()) : const SizedBox();
  Widget get cameraView => isCameraEnabled ? (hostCameraView ?? const SizedBox()) : const SizedBox();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Live page")),
      body: Stack(
        children: [
          Expanded(flex: 1, child: Container(color: Colors.black)),
          Builder(builder: (context) {
            if (!isSharingScreen) return cameraView;
            if (!widget.isHost) return screenView;
            return const Center(child: Text('You are sharing your screen', style: TextStyle(color: Colors.white)));
          }),
          Positioned(
            bottom: 150,
            right: 20,
            child: SizedBox(
              width: MediaQuery.of(context).size.width / 4,
              child: AspectRatio(
                aspectRatio: 9.0 / 16.0,
                child: (isSharingScreen ? cameraView : screenView),
              ),
            ),
          ),
          Positioned(
            bottom: MediaQuery.of(context).size.height / 20,
            left: 0,
            right: 0,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                DemoButton(
                  text: widget.isHost ? 'End Live' : 'Leave Live',
                  onPressed: () => Navigator.pop(context),
                ),
                if (widget.isHost) ...[
                  DemoButton(
                    text: isCameraEnabled ? 'DisableCamera' : 'EnableCamera',
                    onPressed: () {
                      setState(() {
                        isCameraEnabled = !isCameraEnabled;
                        ZegoExpressEngine.instance.setStreamExtraInfo(jsonEncode({'isCameraEnabled': isCameraEnabled}));
                        ZegoExpressEngine.instance.enableCamera(isCameraEnabled);
                      });
                    },
                  ),
                  DemoButton(
                    text: isSharingScreen ? 'StopScreenSharing' : 'StartScreenSharing',
                    onPressed: () async {
                      if (isSharingScreen) {
                        await stopScreenSharing();
                      } else {
                        await startScreenSharing();
                      }
                      setState(() {
                        isSharingScreen = !isSharingScreen;
                      });
                    },
                  ),
                ] else
                  ...[]
              ],
            ),
          ),
        ],
      ),
    );
  }

  Future<ZegoRoomLoginResult> loginRoom() async {
    // The value of `userID` is generated locally and must be globally unique.
    final user = ZegoUser(widget.localUserID, widget.localUserName);

    // The value of `roomID` is generated locally and must be globally unique.
    final roomID = widget.roomID;

    // onRoomUserUpdate callback can be received when "isUserStatusNotify" parameter value is "true".
    ZegoRoomConfig roomConfig = ZegoRoomConfig.defaultConfig()..isUserStatusNotify = true;

    if (kIsWeb) {
      // ! ** Warning: ZegoTokenUtils is only for use during testing. When your application goes live,
      // ! ** tokens must be generated by the server side. Please do not generate tokens on the client side!
      roomConfig.token = ZegoTokenUtils.generateToken(appID, serverSecret, widget.localUserID);
    }
    // log in to a room
    // Users must log in to the same room to call each other.
    return ZegoExpressEngine.instance
        .loginRoom(roomID, user, config: roomConfig)
        .then((ZegoRoomLoginResult loginRoomResult) async {
      debugPrint('loginRoom: errorCode:${loginRoomResult.errorCode}, extendedData:${loginRoomResult.extendedData}');
      if (loginRoomResult.errorCode == 0) {
        if (widget.isHost) {
          await enableScreenSharing();
          startPreview();
          startPublish();
        }
      } else {
        ScaffoldMessenger.of(context)
            .showSnackBar(SnackBar(content: Text('loginRoom failed: ${loginRoomResult.errorCode}')));
      }
      return loginRoomResult;
    });
  }

  Future<ZegoRoomLogoutResult> logoutRoom() async {
    stopPreview();
    stopPublish();
    return ZegoExpressEngine.instance.logoutRoom(widget.roomID);
  }

  void startListenEvent() {
    // Callback for updates on the status of other users in the room.
    // Users can only receive callbacks when the isUserStatusNotify property of ZegoRoomConfig is set to `true` when logging in to the room (loginRoom).
    ZegoExpressEngine.onRoomUserUpdate = (roomID, updateType, List<ZegoUser> userList) {
      debugPrint(
          'onRoomUserUpdate: roomID: $roomID, updateType: ${updateType.name}, userList: ${userList.map((e) => e.userID)}');
    };
    // Callback for updates on the status of the streams in the room.
    ZegoExpressEngine.onRoomStreamUpdate = (roomID, updateType, List<ZegoStream> streamList, extendedData) {
      debugPrint(
          'onRoomStreamUpdate: roomID: $roomID, updateType: $updateType, streamList: ${streamList.map((e) => e.streamID)}, extendedData: $extendedData');
      if (updateType == ZegoUpdateType.Add) {
        for (final stream in streamList) {
          startPlayStream(stream.streamID);
        }
      } else {
        for (final stream in streamList) {
          stopPlayStream(stream.streamID);
        }
      }
    };
    // Callback for updates on the current user's room connection status.
    ZegoExpressEngine.onRoomStateUpdate = (roomID, state, errorCode, extendedData) {
      debugPrint(
          'onRoomStateUpdate: roomID: $roomID, state: ${state.name}, errorCode: $errorCode, extendedData: $extendedData');
    };

    // Callback for updates on the current user's stream publishing changes.
    ZegoExpressEngine.onPublisherStateUpdate = (streamID, state, errorCode, extendedData) {
      debugPrint(
          'onPublisherStateUpdate: streamID: $streamID, state: ${state.name}, errorCode: $errorCode, extendedData: $extendedData');
    };
    ZegoExpressEngine.onPublisherStateUpdate = (streamID, state, errorCode, extendedData) {
      debugPrint(
          'onPublisherStateUpdate: streamID: $streamID, state: ${state.name}, errorCode: $errorCode, extendedData: $extendedData');
    };

    ZegoExpressEngine.onRoomStreamExtraInfoUpdate = (String roomID, List<ZegoStream> streamList) {
      for (ZegoStream stream in streamList) {
        try {
          Map<String, dynamic> extraInfoMap = jsonDecode(stream.extraInfo);
          if (extraInfoMap['isCameraEnabled'] is bool) {
            setState(() {
              isCameraEnabled = extraInfoMap['isCameraEnabled'];
            });
          }
        } catch (e) {
          debugPrint('streamExtraInfo is not json');
        }
      }
    };
  }

  void stopListenEvent() {
    ZegoExpressEngine.onRoomUserUpdate = null;
    ZegoExpressEngine.onRoomStreamUpdate = null;
    ZegoExpressEngine.onRoomStateUpdate = null;
    ZegoExpressEngine.onPublisherStateUpdate = null;
  }

  Future<void> enableScreenSharing() async {
    ZegoExpressEngine.instance.setVideoConfig(
      ZegoVideoConfig.preset(ZegoVideoConfigPreset.Preset540P)..fps = 10,
      channel: ZegoPublishChannel.Aux,
    );
    ZegoExpressEngine.instance.setVideoSource(ZegoVideoSourceType.ScreenCapture, channel: ZegoPublishChannel.Aux);
    screenSharingController = (await ZegoExpressEngine.instance.createScreenCaptureSource())!;
  }

  Future<void> startScreenSharing() async {
    screenSharingController?.startCapture();
    if (hostScreenViewID == null) {
      await ZegoExpressEngine.instance.createCanvasView((viewID) {
        hostScreenViewID = viewID;
        ZegoCanvas previewCanvas = ZegoCanvas(viewID, viewMode: ZegoViewMode.AspectFill);
        // preview
        ZegoExpressEngine.instance.startPreview(canvas: previewCanvas, channel: ZegoPublishChannel.Aux);
        String streamID = '${widget.roomID}_${widget.localUserID}_screen';

        // publish
        ZegoExpressEngine.instance.startPublishingStream(streamID, channel: ZegoPublishChannel.Aux);
      }).then((canvasViewWidget) {
        setState(() => hostScreenView = canvasViewWidget);
      });
    }
  }

  Future<void> stopScreenSharing() async {
    screenSharingController?.stopCapture();
    ZegoExpressEngine.instance.stopPreview(channel: ZegoPublishChannel.Aux);
    ZegoExpressEngine.instance.stopPublishingStream(channel: ZegoPublishChannel.Aux);
    if (hostScreenViewID != null) {
      await ZegoExpressEngine.instance.destroyCanvasView(hostScreenViewID!);
      setState(() {
        hostScreenViewID = null;
        hostScreenView = null;
      });
    }
  }

  Future<void> startPreview() async {
    // cameraView
    await ZegoExpressEngine.instance.createCanvasView((viewID) {
      hostCameraViewID = viewID;
      ZegoCanvas previewCanvas = ZegoCanvas(viewID, viewMode: ZegoViewMode.AspectFill);
      ZegoExpressEngine.instance.startPreview(canvas: previewCanvas, channel: ZegoPublishChannel.Main);
    }).then((canvasViewWidget) {
      setState(() => hostCameraView = canvasViewWidget);
    });
  }

  Future<void> stopPreview() async {
    ZegoExpressEngine.instance.stopPreview(channel: ZegoPublishChannel.Main);
    ZegoExpressEngine.instance.stopPreview(channel: ZegoPublishChannel.Aux);
    if (hostCameraViewID != null) {
      await ZegoExpressEngine.instance.destroyCanvasView(hostCameraViewID!);
      setState(() {
        hostCameraViewID = null;
        hostCameraView = null;
      });
    }
  }

  Future<void> startPublish() async {
    // After calling the `loginRoom` method, call this method to publish streams.
    // The StreamID must be unique in the room.
    String streamID = '${widget.roomID}_${widget.localUserID}_live';
    return ZegoExpressEngine.instance.startPublishingStream(streamID);
  }

  Future<void> stopPublish() async {
    return ZegoExpressEngine.instance.stopPublishingStream();
  }

  Future<void> startPlayStream(String streamID) async {
    // Start to play streams. Set the view for rendering the remote streams.
    if (streamID.endsWith('_screen')) {
      isSharingScreen = true;
      await ZegoExpressEngine.instance.createCanvasView((viewID) {
        hostScreenViewID = viewID;
        ZegoCanvas canvas = ZegoCanvas(viewID, viewMode: ZegoViewMode.AspectFit);
        ZegoExpressEngine.instance.startPlayingStream(streamID, canvas: canvas);
      }).then((canvasViewWidget) {
        setState(() => hostScreenView = canvasViewWidget);
      });
    } else {
      await ZegoExpressEngine.instance.createCanvasView((viewID) {
        hostCameraViewID = viewID;
        ZegoCanvas canvas = ZegoCanvas(viewID, viewMode: ZegoViewMode.AspectFill);
        ZegoExpressEngine.instance.startPlayingStream(streamID, canvas: canvas);
      }).then((canvasViewWidget) {
        setState(() => hostCameraView = canvasViewWidget);
      });
    }
  }

  Future<void> stopPlayStream(String streamID) async {
    ZegoExpressEngine.instance.stopPlayingStream(streamID);
    if (streamID.endsWith('_screen')) {
      isSharingScreen = false;
      if (hostScreenViewID != null) {
        ZegoExpressEngine.instance.destroyCanvasView(hostScreenViewID!);
        setState(() {
          hostScreenViewID = null;
          hostScreenView = null;
        });
      }
    } else {
      if (hostCameraViewID != null) {
        ZegoExpressEngine.instance.destroyCanvasView(hostCameraViewID!);
        setState(() {
          hostCameraViewID = null;
          hostCameraView = null;
        });
      }
    }
  }
}

class DemoButton extends StatelessWidget {
  const DemoButton({
    Key? key,
    required this.onPressed,
    required this.text,
  }) : super(key: key);

  final VoidCallback? onPressed;
  final String text;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: MediaQuery.of(context).size.width / 4,
      height: MediaQuery.of(context).size.width / 7,
      child: ElevatedButton(onPressed: onPressed, child: Text(text)),
    );
  }
}
